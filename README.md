# Проектная работа Sprint 1

Необходимо разбить на микрофронтенды [проект](https://github.com/Yandex-Practicum/architecture-sprint-1)

## 1 Проектирование

Для реализации микрофронтендов будет использоваться фреймворк - Module Federation, так как с ним есть опыт работы (спасибо практической работе)

## 2 Планирование

В проекте четко выделяются зоны ответственности:
- Авторизация
- Настройка профиля
- Карточки с картинками

Можно подумать о выделение лайков в еще один микрофронтенд, что может пригодиться при расширении функционала (например добавят музыку и к ней тоже будут лайки), на текущем этапе удобней воспринимать лайки частью функционала карточек

## 3 Реализация

Создадим 4 микрофронтенда:
- hosts - рут для остальных
- auth - авторизация
- profile - настройка и отображение профиля
- cards - отображение, добавление, удаление карточек. Так же работа с лайками

Большая часть функционала была перенесена

Была попытка упоковать все микрофронтенды в docker-compose, но host падает при сборке, поправить не успел

``cd frontend/microfrontend && docker compose -f compose-micro.yaml up --build``

Так же добавлен вариант запуска всего приложения с микросервисами, но так же с косяками =)

``docker compose -f compose-micro.yaml up --build``

При разбиении приложения было найдено много мягко говоря узких моментов работы с микрофронтендами.

Один из грустных - useHistory используемый в микрофронтендах - будет ссылаться на историю микрофронтенда, что мешает сделать auth полностью независимым. В итоге приходится прокидывать из host такие моменты, что уменьшает независимость

выходит достаточно много связей с host, в итоге на нет сходит разделение ответственности, т.к. зачастую нужно делать промежуточный слой для обмена данными между фронтами.

Если в host для какой-то логики удобно ложится api микросервиса, то он импортируется асинхронно, что тоже не супер приятно в использовании

Периодически дублируются стили/картинки для микрофронтендов

Думаю есть много интересных решений как это дело можно упаковать, но уже сроки =)

# Задание 2

Исходный монолит [локальный файл](task2/arch_template_task2.drawio) | [ссылка](https://drive.google.com/file/d/1X3yoxzmdSeoykihRmb3s-XQEPvO8qThU/view?usp=sharing)

Схема разбитая на микросервисы [локальный файл](task2/arch_template_task2_micro.drawio) | [ссылка](https://drive.google.com/file/d/1BQol45_psp9o5crQXGzzFFMA4ZkvG7rf/view?usp=sharing)

## Разбиение на микросервисы

Было принято решение разбивать на микросервисы по DDD, при разделении создалось впечатление, что в БД явно не хватает полей

Итого получились сервисы:

- Пользователь - все что связано с пользователем: Личные данные, авторизация
- Товар - CRUD по товарам. Если не сильно отличаются можно объединить с Услугой, сложно по схеме понять
- Услуга - CRUD по услугам. Если не сильно отличаются можно объединить с Товаром, сложно по схеме понять
- Заказ - Корзина. заполняется Услугами и Товарами, содержит все необходимые данные для оплаты
- Платежи - хранение транзакций по заказу к платежным сервисам
- Аукцион - не до конца понимаю насколько он связан с товарами/услугами, так что отделил в отдельный микросервис
- Техническая поддержка - сервисный функционал для управления торговой площадкой. По обращениям тоже не хватает полей
- Статистика - обработка данных и подготовка отчетов. Сюда точно не хватает агрегатных полей в базе

На основе данных микросервисов, была разделена БД на схемы :
- Пользователь
- Аукцион
- Торговая площадка (Возможно связана с аукционом, не до конца погрузился в предметную область)
- Услуга
- Товар
- Транзакция

## Описание взаимодействия

1. Инициировать платёж — в микросервисе Заказ есть все необходимые данные для оформления платежа(ID пользователя, ID заказа, сумма заказа). Получаем данные по заказу в микросервис Платежи и инициируем от него общение с платежной системой.

2. Предоставить статус платежа — платёжный сервис принял запрос на проведение оплаты, подтвердил возможность проведения платежа со счёта клиента, назначил идентификатор для этой транзакции и установил статус.

3. Подтверждение платежа — торговая площадка уведомляет платёжный сервис о подтверждении операции, отправляя ID транзакции.

4. Запросить статус платежа — торговая площадка отправляет запрос в платёжный сервис для получения текущего статуса обработки транзакции по ID.

5. Подтверждение отмены платежа (альтернативный сценарий) — платёжный сервис уведомляет систему об успешной отмене платежа, предоставляя статус отменённой транзакции.